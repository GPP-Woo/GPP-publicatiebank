# Generated by Django 4.2.19 on 2025-05-06 10:18

from django.db import migrations, models
from django.db.migrations.state import StateApps

from woo_publications.logging.constants import Events


# content type helper lightly altered and copied from the django manager class for contenttypes
def get_contenttype(apps: StateApps, obj):
    ContentType = apps.get_model("contenttypes", "contenttype")

    def _get_opts(model, for_concrete_model):
        if for_concrete_model:
            model = model._meta.concrete_model
        return model._meta

    def get_for_model(model, for_concrete_model=True):
        """
        Return the ContentType object for a given model, creating the
        ContentType if necessary. Lookups are cached so that subsequent lookups
        for the same model don't hit the database.
        """
        opts = _get_opts(model, for_concrete_model)

        # The ContentType entry was not found in the cache, therefore we
        # proceed to load or create it.
        try:
            # Start with get() and not get_or_create() in order to use
            # the db_for_read (see #20401).
            ct = ContentType.objects.get(
                app_label=opts.app_label, model=opts.model_name
            )
        except ContentType.model.DoesNotExist:
            # Not found in the database; we proceed to create it. This time
            # use get_or_create to take care of any race conditions.
            ct, created = ContentType.objects.get_or_create(
                app_label=opts.app_label,
                model=opts.model_name,
            )
        return ct

    return get_for_model(obj)


# copied and slightly altered code from the ModelOwnerMixin get_owner method.
def get_owner(apps: StateApps, obj):
    """
    Extract the owner from the audit trails.
    """

    def get_acting_user(obj):
        """
        Get information of the acting user.

        Returns a tuple that always contains the recorded acting user metadata as first
        element. The second element is the Django user instance if it is known,
        otherwise ``None``.
        """
        acting_user = {"identifier": "unknown", "display_name": "unknown"}
        match obj.extra_data:
            case {"acting_user": _acting_user} if isinstance(_acting_user, dict):
                acting_user = _acting_user
                acting_user.setdefault("identifier", "unknown")
                acting_user.setdefault("display_name", "unknown")
            case _:
                pass
        return (acting_user, obj.user)

    TimelineLogProxy = apps.get_model("logging", "timelinelogproxy")
    qs = TimelineLogProxy.objects.filter(  # pyright: ignore[reportAttributeAccessIssue]
        content_type=get_contenttype(apps, obj),
        object_id=obj.pk,
    )
    try:
        log = qs.get(extra_data__event=Events.create)
    except TimelineLogProxy.DoesNotExist:
        return None
    assert isinstance(log, TimelineLogProxy)
    return get_acting_user(log)[0]


def set_owner(apps: StateApps, _):
    Document = apps.get_model("publications", "document")
    Publication = apps.get_model("publications", "publication")
    OrganisationMember = apps.get_model("accounts", "organisationmember")
    User = apps.get_model("accounts", "User")

    oldest_user = User.objects.order_by("pk").first()

    for Model in [Document, Publication]:
        for obj in Model.objects.iterator():
            owner = get_owner(apps, obj)
            if not owner:
                # some (dev) environments may have very old data for which no audit trails existed
                assert oldest_user is not None
                owner = {
                    "identifier": str(oldest_user.pk),
                    "display_name": str(oldest_user.username),
                }

            organisation_member, _ = OrganisationMember.objects.get_or_create(
                identifier=owner["identifier"],
                naam=owner["display_name"],
            )

            obj.eigenaar = organisation_member
            obj.save()


class Migration(migrations.Migration):
    dependencies = [
        ("accounts", "0003_organisationmember"),
        ("publications", "0020_topic_afbeelding"),
    ]

    operations = [
        migrations.AddField(
            model_name="document",
            name="eigenaar",
            field=models.ForeignKey(
                help_text="The owner of this document from gpp-app or gpp-publicatiebank.",
                on_delete=models.PROTECT,
                to="accounts.organisationmember",
                verbose_name="owner",
                null=True,
            ),
        ),
        migrations.AddField(
            model_name="publication",
            name="eigenaar",
            field=models.ForeignKey(
                help_text="The owner of this publication from gpp-app or gpp-publicatiebank.",
                on_delete=models.PROTECT,
                to="accounts.organisationmember",
                verbose_name="owner",
                null=True,
            ),
        ),
        migrations.RunPython(set_owner, migrations.RunPython.noop),
        migrations.AlterField(
            model_name="document",
            name="eigenaar",
            field=models.ForeignKey(
                help_text="The owner of this document from gpp-app or gpp-publicatiebank.",
                on_delete=models.PROTECT,
                to="accounts.organisationmember",
                verbose_name="owner",
            ),
        ),
        migrations.AlterField(
            model_name="publication",
            name="eigenaar",
            field=models.ForeignKey(
                help_text="The owner of this publication from gpp-app or gpp-publicatiebank.",
                on_delete=models.PROTECT,
                to="accounts.organisationmember",
                verbose_name="owner",
            ),
        ),
    ]
